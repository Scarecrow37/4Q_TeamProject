인터페이스 모음: InterfaceAPI.h

0. 기본 인터페이스
	ISystem
		:	피직스의 기본적인 시스템을 관리하는 인터페이스
			크게 3가지 기능으로 분류 된다.
				Create
					: Scene이나 Object, Shape, Geometry, Material등 Scene과 Scene을 구성하는 것들을 만드는 기능.
				Update
					: Scene Update, Fetch 기능
				Factory
					: 여러가지 편의성을 제공해서 만들거나 복사해주는 기능

	IScene
		:	개별의 물리 공간으로 시뮬레이션을 담당하는 공간이다.
			Scene에 대한 기능으로 Scene자체에 요청을 담당한다.
			Actor의 추가, SceneQuery등의 기능이 있다.

	IObject
		:	Scene에 배치되어 있는 실제 객체이다.
			움직임이나 충돌(물리 충돌, 트리거 2가지 종류가 있다.) 등 실제 동작을 맡고 있다.
			종류는 크게 다음과 같다.
				IStaticObject
					:	고정된 물체로 물리세상에서 상호작용으로 움직이지 않는다.
						사용자가 직접 움직여 줄 수 있다.
				IDynamicObject
					:	믈리 세상에서 시뮬레이션을 통해 움직일 수 있는 물체이다.
						물리의 영향을 받는다.
				IKinematicObject
					:	물리세상에서 시뮬레이션을 통해 영향은 받지않는 물체이지만,
						다른 물체들과 상호작용은 가능하다.
						사용자에 의해 움직인다.
				3가지 종류의 차이는 다음과 같다.

				Property			|				Static				|			Dynamic				|			Kinematic
				Movement:			|			  Don't move			|	Movement by Physical Engine	|  Control movement with user code	
				Effects of gravity: |				  X					|				O				|			    X
				Crash handling:		|	       Crash detection			|	Crash detection & Respone	|  Crash detection & Respone(One Way)
				Performance:		|		  The most efficient		|		Rather inefficient		|	     About the middle
				Use Cases:			|		Floor, Wall, Obstacles		|	Boxes, Balls, Characters	|	Elevators, Moving platforms

	IShape
		:	Object에게 붙어서 Object의 모양이나 질량같은 속성을 부여해주는 것이다.
			이후 나올 Geometry와 Material을 조합하여서 만들어진다.

	IGeometry
		:	shape에 속하는 속성으로 물체의 실제 모양을 나타낸다.
			종류는 다음과 같다.
				 Basics Geometry
						: Sphere			
						: Capsule			
						: Box				
						: Plane			
										
						: ConvexMesh		
						: TriangleMesh	
						: Frustum		
						
	IMaterial
		:	shape에 속하는 속성으로 물체의 실제 모양을 나타낸다.
			3가지 속성이 있다.
				정지 마찰 계수
				동적 마찰 계수
				반발 계수

	ICollision
		:	충돌을 처리하는 인터페이스로 Object나 Shape의 충돌을 감지 할 수 있다.
			각각의 충돌 방식에 따라 다음과 같이 구분된다.
				// Refer. Unity Collosion
				virtual void __CALLBACK__ OnTriggerEnter()	
				virtual void __CALLBACK__ OnTrigger()		
				virtual void __CALLBACK__ OnTriggerExit()	
				virtual void __CALLBACK__ OnCollisionEnter()
				virtual void __CALLBACK__ OnCollision()		
				virtual void __CALLBACK__ OnCollisionExit()	
				
				// Refer. Unreal Collosion
				virtual void __CALLBACK__ OnHit()			
				virtual void __CALLBACK__ OnOverlapBegin()	
				virtual void __CALLBACK__ OnOverlapEnd()



**********************************************************************************************************
==========================================================================================================
**********************************************************************************************************


1. Basic Initialize

	1.1 IPhysicsSystem초기화
		IPhysicsSystem* physics;

		// 어떠한 PhysicsSystem을 사용 할지 정한 후 초기화 & Physics모드 만들기(default true)
		CreateSystem(&physics, IPhysicsSystem::Physx);
		physics->CreatePhysics(true);

	1.2 IScene초기화
		IScene* m_physicsScene;
		Utils::Description::SceneDesc sceneDesc;

		// SceneDesc을 통해 중력과 CPU쓰래드 갯수를 정한 후
		sceneDesc.gravity = { 0.0f, -9.81f * 5.f, 0.0f };
		sceneDesc.CPUDispatcherCount = 2;

		// Scene초기화
		physics->CreateScene(&m_physicsScene, sceneDesc);

	1.3 Object 만들기
		// Object 생성
		IObject* object;
		physics->CreateObject(&object, Utils::DataStructure::RigidBodyType::Dynamic)

		// Shape 생성
		IShape* Shape;
		IGeometry* Geometry;
		IMaterial* Material;

		// Shape 생성을 위한 Geometry 생성
			// GeometryDesc 설정 후 생성 GeometryDesc 예제의 경우 Box
		Utils::Description::GeometryDesc geometryDesc;
		geometryDesc.type = Utils::DataStructure::GeometryShape::Box;
		geometryDesc.data = { 10, 10, 10 };
		physics->CreateGeometry(&tempGeometry, geometryDesc);

		// Shape 생성을 위한 Meterial 생성
		physics->CreateMaterial(&tempMaterial, { 0.5f, 0.5f, 0.6f });	// 정지 마찰 계수, 동적 마찰 계수, 반발 계수

		// Geometry와 Meterial를 통한 Shape 생성
		physics->CreateShape(&Shape, tempGeometry, tempMaterial);

		// 만들어진 Shape를 Object에게 부착
		object->AttachShape(Shape, true);

		// 만들어진 Object를 Scene에 추가
		Scene->AddActor(object);

		-> 추가적으로 Factory를 통해 여러가지 다양한 생성 기능들이 제공된다.

2. Update & Fetch
		// physicsSystem을 통해 원하는 씬의 번호나 씬을 넣어서 업데이트를 시키고 Fetch를 받는다.
		physics->UpdateScene(m_physicsScene, deltatime);
		physics->FetchScene(m_physicsScene, block = ture);

		:	block의 경우 Update가 끝날떄까지 기다리는 것이다.
			만얀 false일경우 Update의 종료 여뷰와 관계없이 넘어간다.
			이를 확인하기 위해 
			CheckResults라는 함수로 Scene의 종료여부를 확인 할 수 있다.
			(이 또한 block으로 확인이 가능하다.)

3. Additional Function

	3.1 Factory
			:	인터페이스 참조, 정형화된 Create나, Clone등을 제공
	3.2 Scene Query
			:	Fetch가 끝난 정지된 Scene에게 무엇인가 작업을 요청하는 것.
				현재는 3가지가 제공
					Raycast
					Overlap	(미완)
					Sweep
